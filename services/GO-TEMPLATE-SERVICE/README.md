## Как пользоваться данным шаблоном

Данный шаблон микросервиса предназначен для ускорения написания новых микросервисов; имеет заглушки для файла конфигурации, преднастроенную Actor-модель, подключенный логгер с конфигурацией.

### Шаги по кастомизации шаблона

1. Копируем все содержимое папки `GO-TEMPLATE-SERVICE` в папку с именем нового сервиса;
2. Формируем README.md на основе шаблона `README-TEMPLATE.md`

    При формировании README необходимо сделать замену следующих МАКРО-переменных:
    * `<GO-TEMPLATE-SERVICE>` - имя нового сервиса;
    * `<GO-TEMPLATE-SERVICE-IMAGE-ID>` - имя Docker образа для нового сервиса;

3. В файле `Makefile` в секции proto настраиваем список proto файлов, на основе которых необходимо генерировать gRPC, protobuf кодеры (**если это необходимо**);
4. В файле `Dockerfile` заменяем `<GO-TEMPLATE-SERVICE>` на имя своего сервиса;
5. В файле `go.mod` в первой строке заменяем `GO-TEMPLATE-SERVICE` на имя своего сервиса;
6. В файле `src/config/config.go` заменить имя структуры с конфигурацией с `GO_TEMPLATE_SERVICE_Config` на свое имя, и заполните структуры конфигурации согласно вашему сервису.
    * В методе `GetServiceName()` заменить имя сервиса `GO-TEMPLATE-SERVICE` на свое;
    * По необходимости переопределите метод `String()` чтобы конфигурация показывалась корректно;
    * Заполните значения по умолчанию для своего конфига в методе `DefaultConfig()`
7. В файле `config/uc-config.yaml` заполните конфигурацию для своего сервиса. Необходимо заменить имя сервиса `GO-TEMPLATE-SERVICE`, имя секции конфигурации (берется из метода `GetServiceName()` в файле `config.go`). 
8. Настройки логгера производятся в файле `config/logger.yaml`;
9. В файле `src/main.go` заменяем имя сервиса `GO-TEMPLATE-SERVICE` на свое имя;
10. В файле `src/service/test_service_fsm.go` приведен пример пустого actor-сервиса на базе FSM, который регистрируется в Actor модели в файле `src/main.go`. На основе данного actor-сервиса можно реализовывать свои сервисы. При этом необходимо их регистрировать в файле `src/main.go`

По результату выполнения описанных шагов у вас должен получиться компилируемый проект, который можно собрать, запустить. Иметь возможность конфигурировать, настраивать логи.

11. Если необходимо чтобы новый микросервис предоставляет gRPC API, то на основе файла `./../api/protos/GO_TEMLATE_SERVICE.proto` формируем собственное описание сервиса на protobuf, и в файле по пути `<ProjectRoot>/services/golang/Makefile` в последний запуск protoc добавляем ещё одним параметром путь до вашего proto файла. Например, есть создан файл `new_service.proto`, то MakeFile должен приобрести следуюший вид:
```shell
protoc  --go_opt=Mmcptt/mcptt_user_profile.proto=localhost/uc/core/services/golang/api/up \
              --go_opt=Mmcptt/mcptt_group_info.proto=localhost/uc/core/services/golang/api/gi \
              --go_out=./ --go-grpc_out=./ \
              --proto_path="`go list -m -f '{{.Dir}}' localhost/protei-golang/common`/api/protos" \
              --proto_path=./../api/protos/ \
                           mcptt/mcptt_configuration.proto \
...
                           ldap_adapter.proto \
                           new_service.proto
```
12. Переходим в папку `<ProjectRoot>/services/golang` и выполняет команду `make proto`. После этого у вас в папке `<ProjectRoot>/services/golang/api/grpc` сформируются go файлы для gRPC сервисов
13. На основе файла `grpc_service.go` формируем собственную реализацию своего сервиса. Для этого ваш сервис должен реализовывать go интерфейс вашего gRPC сервиса, который сформировался на предыдущем шаге (в тестовом примере интерфейс называется `GoTemplateServiceServer`).
14. Запуск gRPC сервиса осуществляется в файле `src/main.go`, метод `runGRPCServer`. В нем необходимо переопределить имя реализации gRPC сервиса на свое. Там же для тестов добавлен метод `runGRPCClient`. Данный метод делает тестовые запросы, которые через GRPC заходят в определенный диалог FSM, там обрабатываются и отправляются обратно через GRPC.

**Внимание**: для успешной синхронизации go.mod необходимо, чтобы весь код проекта был компилируемый.